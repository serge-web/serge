import React, { Component } from "react";
import FlexLayout from "flexlayout-react";
import Channel from "../Components/Channel";
import _ from "lodash";
import { expiredStorage, LOCAL_STORAGE_TIMEOUT, STATE_OF_WORLD, SUBMIT_PLANS, PERCEPTION_OF_CONTACT, VISIBILIY_CHANGES } from "../consts";
import { getAllWargameMessages } from "../ActionsAndReducers/playerUi/playerUi_ActionCreators";
import { PlayerStateContext } from "../Store/PlayerUi";
import "@serge/themes/dependencies/flexlayout-react.scss";
import "@serge/themes/App.scss";
import { Mapping, Assets, HexGrid } from "@serge/components"
import { saveMapMessage } from '../ActionsAndReducers/playerUi/playerUi_ActionCreators'
import { sendMessage } from '@serge/helpers'

const json = {
  global: {
    tabSetTabStripHeight: 45,
    tabEnableClose: false,
    tabEnableRenderOnDemand: false,
  },
  borders: [],
  layout:{
    "type": "row",
    "weight": 100,
    "children": [
    ]
  }
};


const bounds = {
  imageTop: 14.194809302,
  imageLeft: 42.3558566271,
  imageRight: 43.7417816271,
  imageBottom: 12.401259302
}

const LocalTileLayer = {
  url: './tiles/{z}/{x}/{y}.png',
  attribution: 'Generated by QTiles'
}



class ChannelTabsContainer extends Component {
  static contextType = PlayerStateContext;
  
  static findChannelByName = (channels, name) => {
    return Object.entries(channels).find(entry => {
      const [ , attrs ] = entry;
      return attrs.name === name
    });
  }
  
  constructor(props, context) {
    super(props);
    const [ state, dispatch ] = context;
    let modelName = `FlexLayout-model-${state.currentWargame}-${state.selectedForce}-${state.selectedRole}`;
    let model = expiredStorage.getItem(modelName);
    this.model = model ? FlexLayout.Model.fromJson(JSON.parse(model)) : FlexLayout.Model.fromJson(json);
    this.state = {
      modelName,
    };
    getAllWargameMessages(state.currentWargame)(dispatch);
  }
  
  componentDidUpdate() {
    this.computeTabs();
  }
  
  computeTabs() {
    const [ state ] = this.context;
    let channels = state.channels;
    let channelNames = [];
    
    for (let channelId in channels) {
      channelNames.push({id: channelId, name: channels[channelId].name});
    }
    
    let modelTabs = Object.values(this.model._idMap)
    .filter((node) => node._attributes.type === "tab")
    .map((node) => ({ id: node._attributes.id, name: node._attributes.name }));
    let newChannels = _.differenceBy(channelNames, modelTabs, (channel) => channel.id);
    let channelsToRemove = _.differenceBy(modelTabs, channelNames, (channel) => channel.id);
    let matchingChannels = _.intersectionBy(channelNames, modelTabs, (item) => item.id);
    let channelsToRename = _.differenceBy(matchingChannels, modelTabs, (item) => item.name);
    
    if (channelsToRename.length > 0) {
      this.renameTabs(channelsToRename);
    }
    
    if (newChannels.length > 0) {
      this.addToTabs(newChannels);
    }
    
    if (channelsToRemove.length > 0) {
      this.removeFromTabs(channelsToRemove);
    }
  }
  
  addToTabs(newChannels) {
    let modelTabs = Object.values(this.model._idMap);
    let tabsetMatch = modelTabs.find((tab) => tab._attributes.type === "tabset");
    let tabsetId = tabsetMatch._attributes.id;
    newChannels.forEach((channel) => {
      if (!this.model._idMap[channel.id]) {
        this.model.doAction(
          FlexLayout.Actions.addNode({type: "tab", component: channel.name, name: channel.name, id: channel.id}, tabsetId, FlexLayout.DockLocation.CENTER, -1)
          );
        }
      });
    }
    
    removeFromTabs(channelsToRemove) {
      channelsToRemove.forEach((channel) => {
        if (this.model._idMap[channel.id]) {
          this.model.doAction(
            FlexLayout.Actions.deleteTab(channel.id)
            );
          }
        });
        
        let modelTabs = Object.values(this.model._idMap)
        .filter((node) => node._attributes.type === "tab")
        .map((node) => ({ id: node._attributes.id, name: node._attributes.name }));
        
        if (modelTabs.length === 0) {
          this.addToTabs([{id: "default", name: "No subscriptions"}]);
        }
      }
      
      renameTabs(nameChanges) {
        nameChanges.forEach((channel) => {
          this.model.doAction(
            FlexLayout.Actions.updateNodeAttributes(channel.id, {name: channel.name})
            )
          })
        }
        

  factory = (node) => {
    const [ state ] = this.context;

    const postback = (form, payload, channelID) => {
 
      switch(form) {
        case VISIBILIY_CHANGES:
          sendMessage(VISIBILIY_CHANGES, payload, state.selectedForce, channelID, state.selectedRole, state.currentWargame, saveMapMessage)
          break
        case PERCEPTION_OF_CONTACT:
          sendMessage(PERCEPTION_OF_CONTACT, payload, state.selectedForce, channelID, state.selectedRole, state.currentWargame, saveMapMessage)
          break
        case SUBMIT_PLANS:
          sendMessage(SUBMIT_PLANS, payload, state.selectedForce, channelID, state.selectedRole, state.currentWargame, saveMapMessage)
          break
        case STATE_OF_WORLD:
          sendMessage(STATE_OF_WORLD, payload, state.selectedForce, channelID, state.selectedRole, state.currentWargame, saveMapMessage)
          break
          default:
        console.log('Handler not created for', form)
      }
  
    }

    // Render the map
    const renderMap = channelid => <Mapping
      tileDiameterMins={5}
      bounds={bounds}
      tileLayer={LocalTileLayer}
      forces={state.allForces}
      platforms={state.allPlatformTypes}
      phase={state.phase}
      turnNumber={state.currentTurn}
      playerForce={state.selectedForce}
      canSubmitOrders={true} // TODO get value from role
      channelID = {channelid}
      postBack={postback}
    ><Assets /><HexGrid/>
    </Mapping>

    if (_.isEmpty(state.channels)) return;
    const channelsArray = Object.entries(state.channels);
    if (channelsArray && channelsArray.length === 1) {
      const isOnlyMap = channelsArray.find(entry => entry[1].name.toLowerCase() === "mapping");  
      if (isOnlyMap) {
        return renderMap('map')
      } else {
          return <Channel channelId={channelsArray[0][0]} />;
      }
    } else {
      const matchedChannel = ChannelTabsContainer.findChannelByName(state.channels, node.getName());
      if (node.getName().toLowerCase() === 'mapping') {
   
  
        // return <Mapping currentTurn={state.currentTurn} role={state.selectedRole} currentWargame={state.currentWargame} selectedForce={state.selectedForce} allForces={state.allForces} allPlatforms={state.allPlatformTypes} phase={state.phase} channelID={node._attributes.id} imageTop={imageTop} imageBottom={imageBottom} imageLeft={imageLeft} imageRight={imageRight}></Mapping>
        return renderMap(node._attributes.id)
      }
      return matchedChannel && matchedChannel.length ? <Channel channelId={matchedChannel[0]} /> : null
    }
  };

  modelChanged = () => {
    expiredStorage.setItem(this.state.modelName, JSON.stringify(this.model.toJson()), LOCAL_STORAGE_TIMEOUT);
  };

  setActiveTab = (id) => {
    this.model.doAction(FlexLayout.Actions.selectTab(id));
  };

  tabRender = (node) => {
    let channel;
    const [ state ] = this.context;

    const setUnreadClassName = (className) => {
      if(node._attributes.className !== className) {
        node.getModel().doAction(FlexLayout.Actions.updateNodeAttributes(node.getId(), { className }));
      }
    };

    if (_.isEmpty(state.channels)) return;

    const matchedChannel = ChannelTabsContainer.findChannelByName(state.channels, node.getName());

    channel = matchedChannel && matchedChannel.length > 1 ? matchedChannel[1] : {};

    if (channel.unreadMessageCount === 0) {
      setUnreadClassName('');
    } else if (channel.unreadMessageCount < 9) {
      setUnreadClassName(`unread-${channel.unreadMessageCount}`);
    } else {
      setUnreadClassName(`unread-${channel.unreadMessageCount}plus`);
    }
  };

    render() {
    const [ state ] = this.context;
    let force = state.allForces.find((force) => force.uniqid === state.selectedForce);
   
    return (
      <div className="contain-channel-tabs" data-force={force.uniqid}>
        <FlexLayout.Layout
          model={this.model}
          factory={this.factory}
          onRenderTab={this.tabRender}
          onModelChange={this.modelChanged}
        />
      </div>
    );
  }
}

export default ChannelTabsContainer;
